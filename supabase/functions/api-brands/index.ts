import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    )

    // Get the current user
    const { data: { user }, error: userError } = await supabaseClient.auth.getUser()
    
    if (userError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    const url = new URL(req.url)
    const pathParts = url.pathname.split('/')\n    const brandId = pathParts[pathParts.length - 1]\n\n    if (req.method === 'GET') {\n      if (brandId && brandId !== 'brands') {\n        // Get specific brand\n        return await getBrand(supabaseClient, user.id, brandId)\n      } else {\n        // List user's brands\n        return await listBrands(supabaseClient, user.id)\n      }\n    }\n\n    if (req.method === 'POST') {\n      // Create new brand\n      return await createBrand(supabaseClient, user.id, req)\n    }\n\n    if (req.method === 'PUT' && brandId) {\n      // Update brand\n      return await updateBrand(supabaseClient, user.id, brandId, req)\n    }\n\n    if (req.method === 'DELETE' && brandId) {\n      // Delete brand\n      return await deleteBrand(supabaseClient, user.id, brandId)\n    }\n\n    return new Response(\n      JSON.stringify({ error: 'Method not allowed' }),\n      { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n\n  } catch (error) {\n    console.error('Brands API error:', error)\n    return new Response(\n      JSON.stringify({ error: 'Internal server error' }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n})\n\nasync function listBrands(supabaseClient: any, userId: string) {\n  const { data: brands, error } = await supabaseClient\n    .from('brands')\n    .select(`\n      *,\n      brand_setup_state (\n        completed_steps,\n        is_complete,\n        current_step\n      ),\n      _count:llm_reports(count)\n    `)\n    .eq('owner_id', userId)\n    .order('created_at', { ascending: false })\n\n  if (error) {\n    return new Response(\n      JSON.stringify({ error: 'Failed to fetch brands' }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  // Calculate setup progress for each brand\n  const brandsWithProgress = brands.map((brand: any) => {\n    const setup = brand.brand_setup_state[0] || {}\n    const completedSteps = setup.completed_steps || []\n    const totalSteps = 5 // basic_info, competitors, topics, prompts, verification\n    const progress = (completedSteps.length / totalSteps) * 100\n\n    return {\n      ...brand,\n      setupProgress: {\n        completed: completedSteps,\n        current: setup.current_step,\n        percentage: Math.round(progress),\n        isComplete: setup.is_complete || false,\n      },\n      reportCount: brand._count || 0,\n    }\n  })\n\n  return new Response(\n    JSON.stringify({ brands: brandsWithProgress }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\nasync function getBrand(supabaseClient: any, userId: string, brandId: string) {\n  const { data: brand, error } = await supabaseClient\n    .from('brands')\n    .select(`\n      *,\n      brand_setup_state (\n        completed_steps,\n        is_complete,\n        current_step,\n        setup_data\n      ),\n      brand_topics (\n        id,\n        topic,\n        relevance_score,\n        source,\n        created_at\n      ),\n      brand_prompts (\n        id,\n        prompt,\n        intent_type,\n        performance_score,\n        is_active,\n        created_at\n      ),\n      competitor_meta (\n        id,\n        domain,\n        name,\n        relationship_type,\n        priority_level\n      )\n    `)\n    .eq('id', brandId)\n    .eq('owner_id', userId)\n    .single()\n\n  if (error) {\n    return new Response(\n      JSON.stringify({ error: 'Brand not found' }),\n      { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  // Get recent reports\n  const { data: recentReports } = await supabaseClient\n    .from('llm_reports')\n    .select('id, model_name, score_type, score_value, created_at')\n    .eq('brand_id', brandId)\n    .order('created_at', { ascending: false })\n    .limit(10)\n\n  // Get visibility snapshots for trend\n  const { data: snapshots } = await supabaseClient\n    .from('visibility_snapshots')\n    .select('visibility_pct, positioning_pct, date')\n    .eq('brand_id', brandId)\n    .order('date', { ascending: false })\n    .limit(30)\n\n  const setup = brand.brand_setup_state[0] || {}\n  const completedSteps = setup.completed_steps || []\n  const progress = (completedSteps.length / 5) * 100\n\n  const enrichedBrand = {\n    ...brand,\n    setupProgress: {\n      completed: completedSteps,\n      current: setup.current_step,\n      percentage: Math.round(progress),\n      isComplete: setup.is_complete || false,\n    },\n    analytics: {\n      topicCount: brand.brand_topics?.length || 0,\n      promptCount: brand.brand_prompts?.length || 0,\n      competitorCount: brand.competitor_meta?.length || 0,\n      recentReports: recentReports || [],\n      visibilityTrend: snapshots || [],\n    },\n  }\n\n  return new Response(\n    JSON.stringify({ brand: enrichedBrand }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\nasync function createBrand(supabaseClient: any, userId: string, req: Request) {\n  const { name, domain, industry, description, competitors = [] } = await req.json()\n\n  // Validate required fields\n  if (!name || !domain) {\n    return new Response(\n      JSON.stringify({ error: 'Missing required fields: name, domain' }),\n      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  // Validate domain format\n  const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\\.[a-zA-Z]{2,}$/\n  if (!domainRegex.test(domain)) {\n    return new Response(\n      JSON.stringify({ error: 'Invalid domain format' }),\n      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  // Create brand\n  const { data: brand, error: brandError } = await supabaseClient\n    .from('brands')\n    .insert({\n      owner_id: userId,\n      name,\n      domain,\n      industry: industry || null,\n      description: description || null,\n      competitors: competitors || [],\n    })\n    .select()\n    .single()\n\n  if (brandError) {\n    return new Response(\n      JSON.stringify({ \n        error: brandError.message.includes('duplicate') \n          ? 'Domain already exists' \n          : 'Failed to create brand' \n      }),\n      { status: brandError.message.includes('duplicate') ? 409 : 500, \n        headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  // Create initial setup state\n  await supabaseClient\n    .from('brand_setup_state')\n    .insert({\n      brand_id: brand.id,\n      completed_steps: ['basic_info'],\n      current_step: 'competitors',\n      setup_data: { name, domain, industry, description },\n    })\n\n  return new Response(\n    JSON.stringify({ \n      brand,\n      message: 'Brand created successfully',\n      nextStep: 'competitors',\n    }),\n    { \n      status: 201,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' } \n    }\n  )\n}\n\nasync function updateBrand(supabaseClient: any, userId: string, brandId: string, req: Request) {\n  const { name, description, competitors, industry } = await req.json()\n\n  const updates: any = {}\n  if (name) updates.name = name\n  if (description !== undefined) updates.description = description\n  if (competitors !== undefined) updates.competitors = competitors\n  if (industry !== undefined) updates.industry = industry\n  \n  if (Object.keys(updates).length === 0) {\n    return new Response(\n      JSON.stringify({ error: 'No valid updates provided' }),\n      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  updates.updated_at = new Date().toISOString()\n\n  const { data: brand, error } = await supabaseClient\n    .from('brands')\n    .update(updates)\n    .eq('id', brandId)\n    .eq('owner_id', userId)\n    .select()\n    .single()\n\n  if (error) {\n    return new Response(\n      JSON.stringify({ error: 'Failed to update brand' }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  return new Response(\n    JSON.stringify({ \n      brand,\n      message: 'Brand updated successfully'\n    }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\nasync function deleteBrand(supabaseClient: any, userId: string, brandId: string) {\n  const { error } = await supabaseClient\n    .from('brands')\n    .delete()\n    .eq('id', brandId)\n    .eq('owner_id', userId)\n\n  if (error) {\n    return new Response(\n      JSON.stringify({ error: 'Failed to delete brand' }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n\n  return new Response(\n    JSON.stringify({ message: 'Brand deleted successfully' }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}